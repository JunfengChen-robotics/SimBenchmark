---
layout: default
---
<h1>SimBenchmark</h1>

<p>
    SimBenchmark provides benchmark results of contact simulation on the state-of-the-art physics engines for various robotic tasks.
</p>

<h2>Table of Contents</h2>
<small>
    <ol>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#models">Contact and Multibody Dynamics of Physics Engines</a>
            <ul>
                <li><a href="about/models.html">Backgrounds</a></li>
            </ul>
        </li>
        <li><a href="#list-of-engines">List of Physics Engines</a>
            <ul>
                <li><a href="about/sims.html">Physics engines and benchmark software implementation details</a></li>
            </ul>
        </li>
        <li><a href="#evaluation-metrics">Evaluation Metrics</a>
            <ul>
                <li><a href="about/methodology.html">Methodology details</a></li>
            </ul>
        </li>
        <li><a href="#test-and-result">Test and Results</a></li>
    </ol>
</small>

<h2 id="intro">Introduction</h2>

<p>
    As the robots interact with environments by the contact force, accurate and fast simulation of contact dynamics is crucial for model-based control of robots.
    Notably, the motion of legged robots is highly dependent on the contact force generated by a feet-terrain interaction that drives the entire body.
    It is natural to pursue the realistic and efficient contact simulation for legged robotics research, which enables the successful control of robot locomotion strategy or end-to-end training.
</p>
<p>
    Many rigid body simulation tools that simulate contact dynamics has been introduced to the robotics society, yet the field is fragmented without strong dominance.
    For robotics researchers, it is challenging to find and select the best simulator suits to their robotics tasks among numerous options.
</p>

<div align="center">
    <figure>
        <img src="./img/anymal-walking.gif" alt="anymal-walking-raisim">
        <figcaption>Fig. 1. ANYmal walking in a simulation. <br>Image courtesy of Joonho Lee.</figcaption>
    </figure>
</div>

<p>
    <!-- <div class="row"> -->
    <!-- <div class="column"> -->
    <!-- <img src="./img/mujoco-humanoid.png"> -->
    <!--<figcaption>ANYmal PD control simulation (articulated robot system simulation)</figcaption>-->
    <!-- </div> -->
    <!-- <div class="column"> -->
    <!-- <img src="./img/mujoco-humanoid2.png"> -->
    <!--<figcaption>Zero gravity demo (Single body objects collision simulation)</figcaption>-->
    <!-- </div> -->
    <!-- </div> -->
</p>
<p>
    In this project, we seek to provide an comprehensive evaluation of the accuracy and the speed of contact simulation on the most widely-used physics engines for various situation scenes from single-bodies with a limited number of contacts to complex articulated robotic systems with PD control input.
    Our primary goal is to aid robotics researchers to select the best physics engine for their applications.
</p>

<hr>
<h2 id="models">Contact and Multibody Dynamics of Physics Engines</h2>

<p>
    Solving contact dynamics is NP-hard problem<a href="#[1]">[1]</a> due to its non-convexity and discontinuity.
    To make the problem tractable, physics engines approximate the contact problem as a relaxed problem that enables using efficient solving methods.
    Each method has different characteristics, but some of them significantly sacrifice the accuracy of the contact solution that leads to the poor reality of the simulation.
</p>

<p>
    Moreover, physics engine requires efficient multibody dynamics implementation to be used for complex robot systems.
    For robotic articulated systems that have multiple joints and links, solving the multibody dynamics is considerably expensive as $n$ links have $O(n^3)$ complexity.
    Most state-of-the-art physics engines, therefore, adopt linear complex algorithms that solve the problem in an efficient manner.
</p>

<p>
    In the benchmark tests, we investigated different characteristics of the contact model and multibody dynamics algorithms that each physics engine applies.
</p>

<p>
    Please read <a href="about/models.html">this page</a> for more backgrounds.
</p>

<hr>
<h2 id="list-of-engines">List of Physics Engines</h2>

<p>
    We evaluated the most widely-used physics engines for robotics and machine learning applications.<a href="#[2]">[2]</a>
    The list of the engines is as follows:
<ul>
    <li>RaiSim (unreleased)
        <ul><li><a href="about/sims.html#RaiSim"><b>What is RaiSim?</b></a></li></ul>
    </li>
    <li><a href="http://bulletphysics.org/">Bullet Physics <i>(Bullet)</i></a></li>
    <li><a href="http://www.ode.org/">Open Dynamics Engine <i>(ODE)</i></a></li>
    <li><a href="http://mujoco.org/">Multi-Joint dynamics with Contact <i>(MuJoCo)</i></a></li>
    <li><a href="https://dartsim.github.io/">Dynamic Animation and Robotics Toolkit <i>(DART)</i></a></li>
</ul>
</p>

<p>
    You can find more details about each engine and how they were used in our benchmark software <a href="about/sims.html">here</a>.
</p>

<div align="center">
    <table style="width:100%">
        <col width="15%">
        <col width="17%">
        <col width="17%">
        <col width="17%">
        <col width="17%">
        <col width="17%">
        <tr>
            <td></td>
            <th><small>RaiSim</small></th>
            <th><small>Bullet</small></th>
            <th><small>ODE</small></th>
            <th><small>MuJoCo</small></th>
            <th><small>DART</small></th>
        </tr>
        <tr>
            <th><small>Initial <br> release</small></th>
            <td><small>Unreleased</small></td>
            <td><small>2006</small></td>
            <td><small>2001</small></td>
            <td><small>2015</small></td>
            <td><small>2012</small></td>
        </tr>
        <tr>
            <th><small>Author</small></th>
            <td><small>J. Hwangbo<br>D. Kang</small></td>
            <td><small>E. Coumans</small></td>
            <td><small>R. Smith</small></td>
            <td><small>E. Todorov</small></td>
            <td><small>J. Lee et al</small></td>
        </tr>
        <tr>
            <th><small>License</small></th>
            <td><small>Proprietary</small></td>
            <td><small>Zlib<br>(open-source)</small></td>
            <td><small>GPL / BSD<br>(open-source)</small></td>
            <td><small>Proprietary</small></td>
            <td><small>BSD</small></td>
        </tr>
        <tr>
            <th><small>Main<br>purpose</small></th>
            <td><small>Robotics</small></td>
            <td><small>Game, Graphics</small></td>
            <td><small>Game, Graphics</small></td>
            <td><small>Robotics</small></td>
            <td><small>Robotics</small></td>
        </tr>
        <tr>
            <th><small>Language</small></th>
            <td><small>C++</small></td>
            <td><small>C / C++</small></td>
            <td><small>C++</small></td>
            <td><small>C</small></td>
            <td><small>C++</small></td>
        </tr>
        <tr>
            <th><small>API</small></th>
            <td><small>C++</small></td>
            <td><small>C++ / Python</small></td>
            <td><small>C</small></td>
            <td><small>C</small></td>
            <td><small>C++</small></td>
        </tr>
        <tr>
            <th><small>Contacts</small></th>
            <td><small>Hard</small></td>
            <td><small>Hard/Soft</small></td>
            <td><small>Hard/Soft</small></td>
            <td><small>Soft</small></td>
            <td><small>Hard</small></td>
        </tr>
        <tr>
            <th><small>Solver</small></th>
            <td><small>Bisection</small></td>
            <td><small>MLCP</small></td>
            <td><small>LCP</small></td>
            <td><small>Newton / PGS / CG</small></td>
            <td><small>LCP</small></td>
        </tr>
        <tr>
            <th><small>Integrator</small></th>
            <td><small>Semi-implicit Euler</small></td>
            <td><small>Semi-implicit Euler</small></td>
            <td><small>Semi-implicit Euler</small></td>
            <td><small>Semi-implicit Euler / RK4</small></td>
            <td><small>Semi-implicit Euler</small></td>
        </tr>
        <tr>
            <th><small>Coordinates</small></th>
            <td><small>Minimal</small></td>
            <td><small>Minimal</small></td>
            <td><small>Maximal</small></td>
            <td><small>Minimal</small></td>
            <td><small>Minimal</small></td>
        </tr>
    </table>
</div>

<!--<p>-->
<!--As solving contact dynamics is NP-hard problem due to its non-convexity and discontinuity, physics engines model contact problem as relaxed problem that enables using efficient solving methods.    In order to make the problem tractable,-->
<!--Each physics engine use different contact model and contact solvers thus has different characteristics. Please read <a href="about/models.html">this page</a> for more details-->
<!--</p>-->

<hr>
<h2 id="evaluation-metrics">Evaluation Metrics</h2>

<p>
    The error of the contact simulation is caused by

<ol class="pa">
    <li>inaccurate impulse/force solution from a contact solver</li>
    <li>inherited discretized error from numerical integration.</li>
</ol>

For iterative contact solvers, 1) can be reduced by increasing the number of iteration, and 2) can be reduced by decreasing timestep $dt$.
In both cases, there is a speed-accuracy trade-off: accurate simulation requires more CPU time.
</p>

<p>
    To evaluate the performance in a fair manner, we have to take into account the whole speed-accuracy curve as proposed in <a href="#[3]">[3]</a>.

    In the following example of speed-accuracy curve plot, the ideal engine is on the top-right corner, while most of the engines are represented as the curves sloping downwards from left to right.
    The better engine's curve locates upper-right than others;
    thus the engine 1 represented by curve 1 is better than the engine 2 represented by curve 2.
</p>

<div align="center">
    <figure>
        <img src="img/plot-format.png" alt="plot-format">
        <figcaption>Fig. 2. Speed-accuracy curve format.</figcaption>
    </figure>
</div>

<p>
    Although our lack of knowledge on real physics, we use analytical solution of object trajectory as a reference obtained from Newton's rigid body dynamics and Coulomb's friction cone model when it is applicable:
    for systems with single rigid body with small number of contacts, we find analytical solution of the object trajectory and investigate numerical errors from simulation.
</p>
<p>
    Besides, it may not be possible to find analytical trajectory for complex systems.
    In these cases, we investigate generic physical quantities such as total kinetic energy or linear momentum.
</p>

<p>
    Finally, we also observe position level drift by measuring penetration error that is caused by discretization or inaccurate contact model.
    Apparently it should be zero for rigid body simulation with hard contacts.
</p>

<p>
    More details of benchmark methodology are <a href="about/methodology.html">here</a>.
</p>

<hr>
<h2 id="test-and-result">Test and Results</h2>

<h3>Tests</h3>

<p>
<ul>
    <li><a href="rolling/index.html">Rolling test</a>: friction model test</li>
    <li><a href="bouncing/index.html">Bouncing test</a>: single-body elastic collision test</li>
    <li><a href="666/index.html">666 balls test</a>: single-body hard contact test</li>
    <li><a href="elastic666/index.html">Elastic 666 balls test</a>: single-body energy test</li>
    <!--<li><a href="kapla/kapla.html">Kapla test</a>: single-body stacking test</li>-->
    <li><a href="anymal/index.html">ANYmal PD control test</a>: articulated-robot-system speed test for quadrupedal robot</li>
    <!--<li><a href="atlas/index.html">Atlas PD control test</a>: articulated-robot-system speed test for bipedal robot</li>-->
    <li><a href="anymal-momentum/index.html">ANYmal momentum test</a>: articulated-robot-system momentum test</li>
    <li><a href="anymal-energy/index.html">ANYmal energy test</a>: articulated-robot-system energy test</li>
</ul>
</p>

<h3>Summary of Results</h3>

<p>
    The following table describes the benchmark results assessed by the speed-accuracy curves.
</p>

<div align="center">
    <table style="width:100%">
        <col width="20%">
        <col width="16%">
        <col width="16%">
        <col width="16%">
        <col width="16%">
        <col width="16%">
        <tr>
            <th></th>
            <th>RaiSim</th>
            <th>Bullet</th>
            <th>ODE</th>
            <th>MuJoCo</th>
            <th>DART</th>
        </tr>
        <tr>
            <th>Rolling</th>
            <td>++</td>
            <td><font color="green">+++</font></td>
            <td><font color="red">-</font></td>
            <td>+</td>
            <td><font color="red">-</font></td>
        </tr>
        <tr>
            <th>Bouncing</th>
            <td><font color="green">++++</font></td>
            <td>++</td>
            <td>+++</td>
            <td><font color="red">-</font></td>
            <td>+</td>
        </tr>
        <tr>
            <th>666</th>
            <td><font color="green">+++</font></td>
            <td>+</td>
            <td>++</td>
            <td>+</td>
            <td>+</td>
        </tr>
        <tr>
            <th>Elastic 666</th>
            <td><font color="green">++++</font></td>
            <td>++</td>
            <td>+++</td>
            <td><font color="red">-</font></td>
            <td>+</td>
        </tr>
        <tr>
            <th>ANYmal PD</th>
            <td><font color="green">+++++</font></td>
            <td>+++</td>
            <td>+</td>
            <td>++++</td>
            <td>++</td>
        </tr>
        <!--<tr>-->
            <!--<th>Atlas PD</th>-->
            <!--<td><font color="green">+++++</font></td>-->
            <!--<td>+++</td>-->
            <!--<td><font color="red">-</font></td>-->
            <!--<td>++++</td>-->
            <!--<td>++</td>-->
        <!--</tr>-->
        <tr>
            <th rowspan="2">ANYmal<br>Momentum</th>
            <td rowspan="2">+++</td>
            <td rowspan="2">++</td>
            <td rowspan="2"><font color="green">+++++</font></td>
            <td>++++ <small>(RK4)</small></td>
            <td rowspan="2">+</td>
        </tr>
        <tr>
            <td>++ <small>(Euler)</small></td>
        </tr>
        <tr>
            <th rowspan="2">ANYmal<br>Energy</th>
            <td rowspan="2">++++</td>
            <td rowspan="2">+++</td>
            <td rowspan="2">++</td>
            <td><font color="green">+++++</font> <small>(RK4)</small></td>
            <td rowspan="2">+</td>
        </tr>
        <tr>
            <td>+++ <small>(Euler)</small></td>
        </tr>
    </table>
</div>

<p>
<ul>
    <li>more + is better
    <li><font color="green"><b>+</b></font>: best results
    <li><font color="red">-</font>: cannot simulate due to inaccurate model or excepted
    <!--<li><font color="red">x</font>: simulation fails due to a software error-->
</ul>
</p>

<p>
    ODE generally performs well with single-body primitive shaped objects while MuJoCo and DART have benefits on multibody simulations.
    The multibody system simulation on ODE is very expensive but notably, it outperformed in ANYmal momentum test:
    although it is significantly inefficient, the maximal coordinate representation has good momentum preservability.
    Bullet can simulates slip of the object with frictional contacts very accurately and also efficiently.
</p>
<p>
    But, these engines also reveled their limitations:
<ul>
    <li>the LCP contact model of ODE and DART failed to simulate slip of the object in certain conditions.</li>
    <li>DART's simulation pipeline is not suitable for simulation scenes with many objects.</li>
    <li>Bullet has severe position level drift without the post-solver error correcting method.</li>
    <li>MuJoCo's soft contact model cannot control elasticity of contact.</li>
    <li>MuJoCo has consistent slip which requires additional post-process for legged robot simulation.</li>
</ul>
</p>

<p>
    RaiSim generally has good performance for both single-body and multibody tasks by the virtue of its distinctive contact solving method and efficient multibody dynamics algorithm implementation.
    We expect RaiSim to be an good alternative of the current state-of-the-art engines for contact simulation of robotics applications.
</p>

<hr>

<!--<h2>Conclusion</h2>-->
<h2>Commentary</h2>

<p>
<ul>
    <li>Note that this benchmark is done by Dongho Kang and Jemin Hwangho who are the developers of RaiSim.</li>
    <li>If you have any concern, please contact <a href="mailto:kangd@ethz.ch">Dongho Kang</a>.</li>
</ul>
</p>

<h2>Acknowledgment</h2>

<p>
    Special thanks to Erwin Coumans who is the inventor of Bullet Physics.
</p>


<h2>References</h2>

<ol class="bib">
    <li id="[1]">
        D. Kaufman et al., “Staggered projections for frictional contact in multibody systems,” 2008.
    </li>
    <li id="[2]">
        <a href="https://arxiv.org/pdf/1402.7050.pdf">
            S. Ivaldi et al., "Tools for dynamics simulation of robots: a survey based on user feedback," 2014
        </a>
    </li>
    <li id="[3]">
        <a href="https://arxiv.org/pdf/1402.7050.pdf">
            Tom Erez et al., "Simulation Tools for Model-Based Robotics: Comparison of Bullet, Havok, MuJoCo, ODE and PhysX," 2015
        </a>
    </li>
</ol>
